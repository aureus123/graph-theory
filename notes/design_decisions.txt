Design decisions / talking points

* Graphs
** Why do we represent graphs the way we do?
*** Most proofs treat graphs as monolithic objects (no recursion over node-by-node graph construction)
*** Monolithic graph constructions (quotients, homomorphisms, skeletons, ...) relatively easy to reason about.
*** Combining graphs (as in tree decompositions) is heavyweight and cumbersome.

* Paths
** Paths as structures vs path predicates
*** dedicated xy-path predicates to keep track of the endpoints
    spath G x y p := (x::p) is a G-path and [last x p = y]
*** packaged paths (p : Path x y) allow for strongly typed composition:
    Path x y := { pval : seq G; _ : spath x y pval }
*** Pros (for packaged paths) and Cons:
    + abstracts from the asymmetric underlying representation (i.e., for reversal)
    + strong typing for path concatenation, reversal, splitting, ...
    + fewer assumptions [p: Path x y] rather than [p : seq G; spath G x y p]
    - induction on paths becomes cumbersome 
    - impossilbe to state that ad-hoc constructions on paths (map, filter, ...)
      yield paths.
      (i.e. If p is a G-path, then (filter (mem CP(U)) p) is a path in CP(U))

* Term extraction
** What is the "right" recursion principle to use here?
*** Can avoid proving termination to establish the fixpoint equation and for every correctness property?
*** Is there a (reasonable) functional induction principle?
